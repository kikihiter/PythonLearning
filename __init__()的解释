作者：追远·J
链接：https://www.zhihu.com/question/46973549/answer/767530541
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作为典型的面向对象的语言，Python中 类 的定义和使用是不可或缺的一部分知识。对于有面向对象的经验、对类和实例的概念已经足够清晰的人，学习Python的这套定义规则不过是语法的迁移。但对新手小白而言，要想相对快速地跨过__init__这道坎，还是结合一个简单例子来说比较好。以创建一个“学生”类为例，最简单的语句是class Student():
    pass当然，这样定义的类没有包含任何预定义的数据和功能。除了名字叫Student以外，它没有体现出任何“学生”应该具有的特点。但它是可用的，上述代码运行过后，通过类似stu_1 = Student()这样的语句，我们可以创建一个“学生”实例，即一个具体的“学生”对象。通过class语句定义的类Student，就好像一个“模具”，它可以定义作为一个学生应该具有的各种特点（这里暂未具体定义）；而在类名Student后加圆括号()，组成一个类似函数调用的形式Student()，则执行了一个叫做实例化的过程，即根据定义好的规则，创建一个包含具体数据的学生对象（实例）。为了使用创建的学生实例stu_1，我们可以继续为它添加或修改属性，比如添加一组成绩scores ，由三个整数组成：stu_1.scores = [80, 90, 85]但这样明显存在很多问题，一旦我们需要处理很多学生实例，比如stu_2, stu_3, ...，这样不但带来书写上的麻烦，还容易带来错误，万一某些地方scores打错了，或者干脆忘记了，相应的学生实例就会缺少正确的scores属性。更重要的是，这样的scores属性是暴露出来的，它的使用完全被外面控制着，没有起到“封装”的效果，既不方便也不靠谱。一个自然的解决方案是允许我们在执行实例化过程Student()时传入一些参数，以方便且正确地初始化/设置一些属性值，那么如何定义这种初始化行为呢？答案就是在类内部定义一个__init__函数。这时，Student的定义将变成（我们先用一段注释占着__init__函数内的位置）。class Student():
    def __init__(self, score1, score2, score3):
        # 相关初始化语句定义__init__后，执行实例化的过程须变成Student(arg1, arg2, arg3)，新建的实例本身，连带其中的参数，会一并传给__init__函数自动并执行它。所以__init__函数的参数列表会在开头多出一项，它永远指代新建的那个实例对象，Python语法要求这个参数必须要有，而名称随意，习惯上就命为self。新建的实例传给self后，就可以在__init__函数内创建并初始化它的属性了，比如之前的scores，就可以写为class Student():
    def __init__(self, score1, score2, score3):
        self.scores = [score1, score2, score3]此时，若再要创建拥有具体成绩的学生实例，就只需stu_1 = Student(80, 90, 85)此时，stu_1将已经具有设置好的scores属性。并且由于__init__规定了实例化时的参数，若传入的参数数目不正确，解释器可以报错提醒。你也可以在其内部添加必要的参数检查，以避免错误或不合理的参数传递。在其他方面，__init__就与普通函数无异了。考虑到新手可能对“函数”也掌握得很模糊，这里特别指出几个“无异”之处：独立的命名空间，也就是说函数内新引入的变量均为局部变量，新建的实例对象对这个函数来说也只是通过第一参数self从外部传入的，故无论设置还是使用它的属性都得利用self.<属性名>。如果将上面的初始化语句写成scores = [score1, score2, score3]（少了self.），则只是在函数内部创建了一个scores变量，它在函数执行完就会消失，对新建的实例没有任何影响；与此对应，self的属性名和函数内其他名称(包括参数)也是不冲突的，所以你可能经常见到类似这种写法，它正确而且规范。class Student():
    def __init__(self, name, scores):
        # 这里增加了属性name，并将所有成绩作为一个参数scores传入
        # self.name是self的属性，单独的name是函数内的局部变量，参数也是局部变量
        self.name = name
        if len(scores) == 3:
            self.scores = scores
        else:
            self.scores = [0] * 3从第二参数开始均可设置变长参数、默认值等，相应地将允许实例化过程Student()中灵活地传入需要数量的参数；其他……说到最后，__init__还是有个特殊之处，那就是它不允许有返回值。如果你的__init__过于复杂有可能要提前结束的话，使用单独的return就好，不要带返回值。
